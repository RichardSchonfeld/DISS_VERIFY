<!DOCTYPE html>
<html>
<head>
    <title>Sign Certificate</title>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.3.0/dist/web3.min.js"></script>
</head>
<body>
    <h1>Sign Your Certificate</h1>
    <form id="decrypt-form" method="POST" action="{% url 'sign_certificate' %}">
        {% csrf_token %}

        <label for="claim">Select Claim:</label>
        <select id="claim" name="claim_id">
            {% for claim in unsigned_claims %}
                <option value="{{ claim.id }}">{{ claim.full_name }} ({{ claim.year_of_graduation }})</option>
            {% endfor %}
        </select><br><br>

        <button type="submit">Prepare Certificate</button>
    </form>

    <div id="certificate-container" style="display:none;">
        <h2>Certificate Data</h2>
        <pre id="certificate-data"></pre>
        <button id="sign-button" style="display:none;">Sign Certificate</button>
    </div>

    <script>
        document.getElementById('decrypt-form').addEventListener('submit', async function(event) {
            event.preventDefault();

            const formData = new FormData(event.target);
            const response = await fetch(event.target.action, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                document.getElementById('certificate-data').textContent = JSON.stringify(data.certificate_data, null, 2);
                document.getElementById('certificate-container').style.display = 'block';
                document.getElementById('sign-button').style.display = 'block';

                // Handle the signing using MetaMask or decrypted private key
                document.getElementById('sign-button').addEventListener('click', async () => {
                    const isWeb3User = {{ user.is_web3_user|lower }};

                    try {
                        if (isWeb3User) {
                            const web3 = new Web3(window.ethereum);
                            await ethereum.request({ method: 'eth_requestAccounts' });
                            const account = (await web3.eth.getAccounts())[0];

                            // Sign the hash using MetaMask
                            web3.eth.personal.sign(data.certificate_hash, account, (err, signature) => {
                                if (err) {
                                    console.error('MetaMask signing failed', err);
                                    return;
                                }
                                submitSignature(signature, data.certificate_data, data.certificate_hash);
                            });
                        } else {
                            const encryptedPrivateKey = document.getElementById('encrypted_private_key').value;
                            const password = document.getElementById('password').value;
                            const decryptedPrivateKey = await decryptPrivateKey(encryptedPrivateKey, password);

                            const web3 = new Web3();
                            const privateKeyObject = web3.eth.accounts.privateKeyToAccount(decryptedPrivateKey);
                            const signature = privateKeyObject.sign(data.certificate_hash);

                            submitSignature(signature.signature, data.certificate_data, data.certificate_hash);
                        }
                    } catch (error) {
                        console.error('Submit signature failed:', error);
                    }
                });
            } else {
                alert('Failed to prepare certificate.');
            }
        });

        function submitSignature(signature, certificateData, certificateHash) {
            fetch('/store-signed-certificate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    certificate: certificateData,
                    certificate_hash: certificateHash,
                    signature: signature
                })
            }).then(response => response.json())
              .then(data => {
                  console.log('Success:', data);
              })
              .catch((error) => {
                  console.error('Error:', error);
              });
        }

        async function decryptPrivateKey(encryptedPrivateKey, password) {
            // Code for decryption of private key remains the same
        }
    </script>
</body>
</html>
