<!DOCTYPE html>
<html>
<head>
    <title>Sign Certificate</title>
    {% load static %}
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.3.0/dist/web3.min.js"></script>
    <script src="{% static 'js/encryption.js' %}"></script>
</head>
<body>
    <h1>Sign Your Certificate</h1>
    <form id="decrypt-form" method="POST" action="{% url 'sign_certificate' %}">
        {% csrf_token %}

        <label for="claim">Select Claim:</label>
        <select id="claim" name="claim_id">
            {% for claim in unsigned_claims %}
                <option value="{{ claim.id }}">{{ claim.requester.username }} ({{ claim.created_at }})</option>
            {% endfor %}
        </select><br><br>

        <button type="submit">Prepare Certificate</button>
    </form>

    <div id="certificate-container" style="display:none;">
        <h2>Certificate Data</h2>
        <pre id="certificate-data"></pre>

        <!-- PDF preview section -->
        <h2>Certificate PDF Preview</h2>
        <embed id="pdf-preview" type="application/pdf" width="600" height="800" style="display:none;" />

        <!-- Download link for the PDF -->
        <a id="pdf-download-link" href="#" download="certificate.pdf" style="display:none;">Download Certificate PDF</a>

        <br><br>
        <button id="sign-button" style="display:none;">Sign Certificate</button>
    </div>

    {% if encrypted_private_key %}
        <label for="password">Enter your password to decrypt your private key:</label>
        <input type="password" id="password" name="password" required>
        <input type="hidden" id="encrypted_private_key" value="{{encrypted_private_key}}">
    {% endif %}

    <script>
        document.getElementById('decrypt-form').addEventListener('submit', async function(event) {
            event.preventDefault();

            const formData = new FormData(event.target);
            const response = await fetch(event.target.action, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                document.getElementById('certificate-data').textContent = JSON.stringify(data.certificate_data, null, 2);
                document.getElementById('certificate-container').style.display = 'block';
                document.getElementById('sign-button').style.display = 'block';

                // Show the PDF preview or download link
                displayPdfPreview(data.certificate_pdf_base64);

                // Handle the signing using MetaMask or decrypted private key
                document.getElementById('sign-button').addEventListener('click', async () => {
                    const isWeb3User = {{ user.is_web3_user|lower }};
                    const certificatePdfBase64 = data.certificate_pdf_base64;

                    try {
                        if (isWeb3User) {
                            const web3 = new Web3(window.ethereum);
                            await ethereum.request({ method: 'eth_requestAccounts' });
                            const account = (await web3.eth.getAccounts())[0];

                            // Sign the hash using MetaMask
                            web3.eth.personal.sign(data.certificate_hash, account, async (err, signature) => {
                                if (err) {
                                    console.error('MetaMask signing failed', err);
                                    return;
                                }
                                // After signing, upload to IPFS and submit the hash
                                await handleIpfsUploadAndSubmit(certificatePdfBase64, signature, data.certificate_data, data.certificate_hash);
                            });
                        } else {
                            const encryptedPrivateKey = document.getElementById('encrypted_private_key').value;
                            const password = document.getElementById('password').value;
                            const decryptedPrivateKey = await decryptPrivateKey(encryptedPrivateKey, password);

                            const web3 = new Web3();
                            const privateKeyObject = web3.eth.accounts.privateKeyToAccount(decryptedPrivateKey);
                            const signature = privateKeyObject.sign(data.certificate_hash).signature;

                            // After signing, upload to IPFS and submit the hash
                            await handleIpfsUploadAndSubmit(certificatePdfBase64, signature, data.certificate_data, data.certificate_hash);
                        }
                    } catch (error) {
                        console.error('Submit signature failed:', error);
                    }
                });
            } else {
                alert('Failed to prepare certificate.');
            }
        });



        function submitSignature(ipfsHash, signature, certificateData, certificateHash) {
            return fetch('/store-signed-certificate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    certificate: certificateData,
                    certificate_hash: certificateHash,
                    ipfs_hash: ipfsHash,
                    signature: signature
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Success:', data);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        }

        // Function to display PDF in-browser or as a downloadable link
        function displayPdfPreview(base64Pdf) {
            const pdfBlob = base64ToBlob(base64Pdf, 'application/pdf');

            // Display PDF in an <embed> tag
            const pdfPreview = document.getElementById('pdf-preview');
            pdfPreview.src = URL.createObjectURL(pdfBlob);
            pdfPreview.style.display = 'block';

            // Create a downloadable link
            const downloadLink = document.getElementById('pdf-download-link');
            downloadLink.href = URL.createObjectURL(pdfBlob);
            downloadLink.style.display = 'block';
        }

        // Helper function to convert base64 to Blob
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length).fill(null).map((_, i) => byteCharacters.charCodeAt(i));
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }
    </script>
</body>
</html>
