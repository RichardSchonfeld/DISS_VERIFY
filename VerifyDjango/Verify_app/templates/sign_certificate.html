<!DOCTYPE html>
<html>
<head>
    <title>Sign Certificate</title>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.3.0/dist/web3.min.js"></script>
</head>
<body>
    <h1>Sign Your Certificate</h1>
    <form id="decrypt-form" method="POST" action="{% url 'sign_certificate' %}">
        {% csrf_token %}  <!-- Include CSRF token -->

        <label for="ipfs_hash">IPFS Hash:</label>
        <input type="text" id="ipfs_hash" name="ipfs_hash" required><br><br>

        <label for="share1">Share 1:</label>
        <input type="text" id="share1" name="share1" required><br><br>

        <label for="share2">Share 2:</label>
        <input type="text" id="share2" name="share2" required><br><br>

        <button type="submit">Decrypt and Prepare</button>
    </form>

    <div id="certificate-container" style="display:none;">
        <h2>Certificate Data</h2>
        <pre id="certificate-data"></pre>
        <button id="sign-button" style="display:none;">Sign Certificate</button>
    </div>

    <script>
        document.getElementById('decrypt-form').addEventListener('submit', async function(event) {
            event.preventDefault();

            const formData = new FormData(event.target);
            const response = await fetch(event.target.action, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                document.getElementById('certificate-data').textContent = JSON.stringify(data.certificate_data, null, 2);
                document.getElementById('certificate-container').style.display = 'block';
                document.getElementById('sign-button').style.display = 'block';

                // Now, handle the signing using MetaMask or decrypted private key
                document.getElementById('sign-button').addEventListener('click', async () => {
                    let useMetaMask = confirm('Do you want to sign using MetaMask?');

                    if (useMetaMask) {
                        const web3 = new Web3(window.ethereum);
                        await ethereum.request({ method: 'eth_requestAccounts' });
                        const account = (await web3.eth.getAccounts())[0];

                        // Sign the hash using MetaMask
                        web3.eth.personal.sign(data.certificate_hash, account, (err, signature) => {
                            if (err) {
                                console.error('MetaMask signing failed', err);
                                return;
                            }
                            submitSignature(signature, data.certificate_data, data.certificate_hash);
                        });
                    } else {
                        // Decrypt the private key and sign the certificate hash
                        const password = prompt("Enter your password to decrypt your private key:");
                        const encryptedPrivateKey = prompt("Paste your encrypted private key:");
                        const decryptedPrivateKey = await decryptPrivateKey(encryptedPrivateKey, password);

                        const web3 = new Web3();
                        const privateKeyObject = web3.eth.accounts.privateKeyToAccount(decryptedPrivateKey);
                        const signature = privateKeyObject.sign(data.certificate_hash);

                        submitSignature(signature.signature, data.certificate_data, data.certificate_hash);
                    }
                });
            } else {
                alert('Failed to decrypt data.');
            }
        });

        function submitSignature(signature, certificateData, certificateHash) {
            fetch('/store-signed-certificate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    certificate: certificateData,
                    certificate_hash: certificateHash,
                    signature: signature
                })
            }).then(response => response.json())
              .then(data => {
                  console.log('Success:', data);
              })
              .catch((error) => {
                  console.error('Error:', error);
              });
        }

        async function decryptPrivateKey(encryptedPrivateKey, password) {
            const encryptedKeyBytes = Uint8Array.from(atob(encryptedPrivateKey), c => c.charCodeAt(0));
            const salt = encryptedKeyBytes.slice(0, 16);
            const iv = encryptedKeyBytes.slice(16, 32);
            const encryptedData = encryptedKeyBytes.slice(32);

            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveKey"]
            );

            const key = await crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-CBC", length: 256 },
                false,
                ["decrypt"]
            );

            const decrypted = await crypto.subtle.decrypt(
                { name: "AES-CBC", iv: iv },
                key,
                encryptedData
            );

            return new TextDecoder().decode(decrypted);
        }
    </script>
</body>
</html>
