<!DOCTYPE html>
<html>
<head>
    <title>Sign Certificate</title>
    {% load static %}
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.3.0/dist/web3.min.js"></script>
    <script src="{% static 'js/encryption.js' %}"></script>
</head>
<body>
    <h1>Sign Your Certificate</h1>
    <form id="decrypt-form" method="POST" action="{% url 'sign_certificate' %}">
        {% csrf_token %}

        <label for="claim">Select Claim:</label>
        <select id="claim" name="claim_id">
            {% for claim in unsigned_claims %}
                <option value="{{ claim.claim_id }}">{{ claim.requester.username }} ({{ claim.created_at }})</option>
            {% endfor %}
        </select><br><br>

        <button type="submit">Prepare Certificate</button>
    </form>

    <div id="certificate-container" style="display:none;">
        <h2>Certificate Data</h2>
        <pre id="certificate-data"></pre>

        <!-- PDF preview section -->
        <h2>Certificate PDF Preview</h2>
        <embed id="pdf-preview" type="application/pdf" width="600" height="800" style="display:none;" />

        <!-- Download link for the PDF -->
        <a id="pdf-download-link" href="#" download="certificate.pdf" style="display:none;">Download Certificate PDF</a>

        <br><br>
        <button id="sign-button" style="display:none;">Sign Certificate</button>
    </div>

    {% if encrypted_private_key %}
        <label for="password">Enter your password to decrypt your private key:</label>
        <input type="password" id="password" name="password" required>
        <input type="hidden" id="encrypted_private_key" value="{{encrypted_private_key}}">
    {% endif %}

    <script>
        document.getElementById('decrypt-form').addEventListener('submit', async function(event) {
            event.preventDefault();

            const formData = new FormData(event.target);
            const response = await fetch(event.target.action, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();

                // Display the certificate data
                document.getElementById('certificate-data').textContent = JSON.stringify(data.certificate_data, null, 2);
                document.getElementById('certificate-container').style.display = 'block';
                document.getElementById('sign-button').style.display = 'block';

                // Show the PDF preview or download link
                displayPdfPreview(data.certificate_pdf_base64);

                // Store the transaction and certificate hash for signing
                const transactionData = JSON.parse(data.transaction);
                const certificateHash = data.certificate_hash;
                const selectedClaimId = data.selected_claim_id;
                const contractAbi = data.contract_abi;  // Contract ABI from backend
                const contractAddress = data.contract_address;  // Contract address from backend

                // Initialize Web3
                const web3 = new Web3(window.ethereum || new Web3.providers.HttpProvider('http://localhost:8545'));
                const contract = new web3.eth.Contract(contractAbi, contractAddress);

                // Prepare the signing process when the user clicks the "Sign Certificate" button
                document.getElementById('sign-button').addEventListener('click', async () => {
                    const isWeb3User = {{ user.is_web3_user|lower }};
                    try {
                        if (isWeb3User) {
                            // MetaMask user flow
                            await ethereum.request({ method: 'eth_requestAccounts' });
                            const account = (await web3.eth.getAccounts())[0];

                            // Sign the certificate hash using MetaMask
                            const signature = await web3.eth.personal.sign(certificateHash, account);

                            // Send the transaction to the contract
                            const txnHash = await contract.methods.signClaim(selectedClaimId, signature).send({
                                from: account,
                                gas: transactionData.gas,
                                gasPrice: transactionData.gasPrice
                            });

                            // Submit the signed certificate and transaction hash to the backend
                            await submitSignedCertificate(data.certificate_pdf_base64, signature, selectedClaimId, txnHash.transactionHash);

                        } else {
                            // Non-Web3 user flow (local signing)
                            const encryptedPrivateKey = document.getElementById('encrypted_private_key').value;
                            const password = document.getElementById('password').value;
                            const decryptedPrivateKey = await decryptPrivateKey(encryptedPrivateKey, password);

                            const privateKeyObject = web3.eth.accounts.privateKeyToAccount(decryptedPrivateKey);

                            // Sign the certificate hash with the decrypted private key
                            const signature = privateKeyObject.sign(certificateHash).signature;

                            // Encode transaction data
                            const txnData = contract.methods.signClaim(selectedClaimId, signature).encodeABI();

                            // Build and sign the transaction
                            const tx = {
                                from: privateKeyObject.address,
                                to: contractAddress,
                                gas: transactionData.gas,
                                gasPrice: transactionData.gasPrice,
                                data: txnData
                            };

                            const signedTransaction = await web3.eth.accounts.signTransaction(tx, decryptedPrivateKey);
                            const txnReceipt = await web3.eth.sendSignedTransaction(signedTransaction.rawTransaction);

                            // Submit the signed certificate and transaction hash to the backend
                            await submitSignedCertificate(data.certificate_pdf_base64, signature, selectedClaimId, txnReceipt.transactionHash);
                        }
                    } catch (error) {
                        console.error('Signing failed:', error);
                        alert('Error occurred during signing.');
                    }
                });
            } else {
                alert('Failed to prepare certificate.');
            }
        });

        async function submitSignedCertificate(certificatePdfBase64, signature, selectedClaimId, txnHash) {
            try {
                const response = await fetch('/store-signed-certificate/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        certificate_pdf_base64: certificatePdfBase64,
                        signature: signature,
                        selected_claim_id: selectedClaimId,
                        txn_hash: txnHash
                    })
                });

                if (response.ok) {
                    alert('Certificate signed and submitted successfully!');
                    window.location.href = '/';
                } else {
                    alert('Failed to submit the signed certificate.');
                }
            } catch (error) {
                console.error('Error submitting signed certificate:', error);
            }
        }

        // Function to display PDF in-browser or as a downloadable link
        function displayPdfPreview(base64Pdf) {
            const pdfBlob = base64ToBlob(base64Pdf, 'application/pdf');
            const pdfPreview = document.getElementById('pdf-preview');
            pdfPreview.src = URL.createObjectURL(pdfBlob);
            pdfPreview.style.display = 'block';

            const downloadLink = document.getElementById('pdf-download-link');
            downloadLink.href = URL.createObjectURL(pdfBlob);
            downloadLink.style.display = 'block';
        }

        // Helper function to convert base64 to Blob
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length).fill(null).map((_, i) => byteCharacters.charCodeAt(i));
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }
    </script>
</body>
</html>
